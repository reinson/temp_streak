<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Data Visualization - Compact</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 10px;
            color: #333;
            margin: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .header a {
            color: #3498db;
            text-decoration: none;
        }

        .header a:hover {
            text-decoration: underline;
        }

        .container {
            width: 100%;
            margin: 0;
            background: white;
            padding: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .chart-container {
            margin-bottom: 3px;
        }

        .chart-container:last-child {
            margin-bottom: 0;
        }

        .chart-svg {
            width: 100%;
            height: 35px;
            display: block;
        }

        .chart-label {
            font-size: 12px;
            fill: #2c3e50;
            font-weight: 600;
        }

        .chart-stats-text {
            font-size: 11px;
            fill: #7f8c8d;
        }

        .line {
            fill: none;
            stroke-width: 1.5;
            vector-effect: non-scaling-stroke;
        }

        .line-below-zero {
            stroke: #3498db;
        }

        .line-above-zero {
            stroke: #e74c3c;
        }

        .axis {
            stroke: #bdc3c7;
            stroke-width: 0.5;
        }

        .axis-text {
            font-size: 10px;
            fill: #95a5a6;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="/">← Back to Wide View</a>
    </div>
    <div class="container">
        <div id="charts-container">
            <div class="loading">Loading data...</div>
        </div>
    </div>

    <script>
        // Parse CSV data in chunks to avoid stack overflow
        async function parseCSV(text) {
            const years = {};
            let minTemp = Infinity;
            let maxTemp = -Infinity;
            
            // Process line by line without splitting entire file
            let currentPos = 0;
            let lineStart = 0;
            let lineNum = 0;
            
            while (currentPos < text.length) {
                // Find end of line
                let lineEnd = text.indexOf('\n', currentPos);
                if (lineEnd === -1) lineEnd = text.length;
                
                if (lineNum > 0) { // Skip header
                    const line = text.substring(lineStart, lineEnd).trim();
                    if (line) {
                        const commaIdx = line.indexOf(', ');
                        if (commaIdx > 0) {
                            const dateStr = line.substring(0, commaIdx);
                            const temp = parseFloat(line.substring(commaIdx + 2));
                            
                            if (!isNaN(temp)) {
                                const date = new Date(dateStr);
                                const year = date.getFullYear();
                                
                                if (!years[year]) {
                                    years[year] = [];
                                }
                                
                                years[year].push({
                                    date: date,
                                    temp: temp
                                });
                                
                                if (temp < minTemp) minTemp = temp;
                                if (temp > maxTemp) maxTemp = temp;
                            }
                        }
                    }
                }
                
                lineNum++;
                currentPos = lineEnd + 1;
                lineStart = currentPos;
                
                // Yield control periodically to avoid blocking
                if (lineNum % 100000 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Sort each year's data by date
            Object.keys(years).forEach(year => {
                years[year].sort((a, b) => a.date - b.date);
            });
            
            return { years, minTemp, maxTemp };
        }

        // Downsample data to reduce points (for smoother rendering)
        function downsample(data, maxPoints = 2000) {
            if (data.length <= maxPoints) return data;
            
            const step = Math.ceil(data.length / maxPoints);
            const sampled = [];
            
            for (let i = 0; i < data.length; i += step) {
                sampled.push(data[i]);
            }
            
            // Always include the last point
            if (sampled[sampled.length - 1] !== data[data.length - 1]) {
                sampled.push(data[data.length - 1]);
            }
            
            return sampled;
        }

        // Create a line chart for a year
        function createYearChart(year, data) {
            // Use fixed viewBox width for consistent scaling, SVG will scale to 100% width
            const width = 1200; // Fixed viewBox width
            const height = 35;
            const labelWidth = 50; // Space for year label on left
            const statsWidth = 220; // Space for stats on right
            const padding = { top: 3, right: statsWidth, bottom: 8, left: labelWidth + 5 }; // Right padding accounts for stats
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Downsample data for rendering (keep all for stats)
            const displayData = downsample(data, 2000);
            
            // Calculate stats using all data (iterative to avoid stack overflow)
            let sum = 0;
            let minYearTemp = Infinity;
            let maxYearTemp = -Infinity;
            for (let i = 0; i < data.length; i++) {
                const temp = data[i].temp;
                sum += temp;
                if (temp < minYearTemp) minYearTemp = temp;
                if (temp > maxYearTemp) maxYearTemp = temp;
            }
            const avgTemp = sum / data.length;

            // Create SVG (responsive width)
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'chart-svg');
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', height);

            // Create group for chart content
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${padding.left}, ${padding.top})`);

            // Fixed y-axis range
            const fixedMinTemp = -30;
            const fixedMaxTemp = 35;
            
            // Fixed x-domain: Jan 1 to Dec 31 of the year
            const yearStart = new Date(year, 0, 1); // January 1
            const yearEnd = new Date(year, 11, 31, 23, 59, 59); // December 31
            const yearDuration = yearEnd - yearStart;
            
            // Scale functions - x based on date, y based on temperature
            const xScale = (date) => {
                const dayOfYear = (date - yearStart) / yearDuration;
                return Math.max(0, Math.min(chartWidth, dayOfYear * chartWidth));
            };
            const yScale = (temp) => chartHeight - ((temp - fixedMinTemp) / (fixedMaxTemp - fixedMinTemp)) * chartHeight;

            // Split data into segments above and below zero
            function createPathSegments(data) {
                const segments = [];
                let currentSegment = null;
                
                for (let i = 0; i < data.length; i++) {
                    const point = data[i];
                    const isAboveZero = point.temp > 0;
                    const x = xScale(point.date);
                    const y = yScale(point.temp);
                    
                    if (currentSegment === null) {
                        // Start first segment
                        currentSegment = {
                            isAboveZero: isAboveZero,
                            pathData: `M ${x} ${y}`
                        };
                    } else if (currentSegment.isAboveZero !== isAboveZero) {
                        // Crossing zero - calculate intersection point
                        const prevPoint = data[i - 1];
                        const prevX = xScale(prevPoint.date);
                        const prevY = yScale(prevPoint.temp);
                        
                        // Linear interpolation to find zero crossing
                        const t = -prevPoint.temp / (point.temp - prevPoint.temp);
                        const zeroX = prevX + (x - prevX) * t;
                        const zeroY = yScale(0);
                        
                        // Close current segment at zero
                        currentSegment.pathData += ` L ${zeroX} ${zeroY}`;
                        segments.push(currentSegment);
                        
                        // Start new segment from zero
                        currentSegment = {
                            isAboveZero: isAboveZero,
                            pathData: `M ${zeroX} ${zeroY} L ${x} ${y}`
                        };
                    } else {
                        // Continue current segment
                        currentSegment.pathData += ` L ${x} ${y}`;
                    }
                }
                
                if (currentSegment !== null) {
                    segments.push(currentSegment);
                }
                
                return segments;
            }
            
            // Create month tick marks (12 ticks for Jan-Dec)
            function createMonthTicks() {
                const ticks = [];
                for (let month = 0; month < 12; month++) {
                    const monthDate = new Date(year, month, 1);
                    const x = xScale(monthDate);
                    ticks.push(x);
                }
                return ticks;
            }
            
            // Create path segments
            const segments = createPathSegments(displayData);
            
            // Render each segment with appropriate color
            segments.forEach(segment => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', segment.pathData);
                path.setAttribute('class', `line ${segment.isAboveZero ? 'line-above-zero' : 'line-below-zero'}`);
                g.appendChild(path);
            });

            // Add zero line (freezing point) - full width
            const zeroY = yScale(0);
            if (zeroY >= 0 && zeroY <= chartHeight) {
                const zeroLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                zeroLine.setAttribute('x1', 0);
                zeroLine.setAttribute('y1', zeroY);
                zeroLine.setAttribute('x2', chartWidth);
                zeroLine.setAttribute('y2', zeroY);
                zeroLine.setAttribute('class', 'axis');
                zeroLine.setAttribute('stroke-dasharray', '2,2');
                zeroLine.setAttribute('opacity', '0.5');
                g.appendChild(zeroLine);
            }
            
            // Add month tick marks
            const monthTicks = createMonthTicks();
            monthTicks.forEach(x => {
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', chartHeight);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', chartHeight + 3);
                tick.setAttribute('class', 'axis');
                tick.setAttribute('stroke-width', '0.5');
                g.appendChild(tick);
            });

            svg.appendChild(g);

            // Add year label on the left (after group so it appears on top)
            const yearLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yearLabel.setAttribute('x', 5); // Small offset from left edge
            yearLabel.setAttribute('y', padding.top + chartHeight / 2);
            yearLabel.setAttribute('class', 'chart-label');
            yearLabel.setAttribute('dominant-baseline', 'middle');
            yearLabel.textContent = year;
            svg.appendChild(yearLabel);
            
            // Add stats on the right (within the right padding area, right-aligned)
            const statsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            statsText.setAttribute('x', width - 10); // Position near right edge with small margin
            statsText.setAttribute('y', padding.top + chartHeight / 2);
            statsText.setAttribute('class', 'chart-stats-text');
            statsText.setAttribute('text-anchor', 'end'); // Right-align the text
            statsText.setAttribute('dominant-baseline', 'middle');
            statsText.textContent = `Avg: ${avgTemp.toFixed(1)}°C | Min: ${minYearTemp.toFixed(1)}°C | Max: ${maxYearTemp.toFixed(1)}°C`;
            svg.appendChild(statsText);

            // Create container
            const container = document.createElement('div');
            container.className = 'chart-container';
            container.appendChild(svg);
            
            return container;
        }

        // Main function
        async function loadAndVisualize() {
            try {
                document.getElementById('charts-container').innerHTML = 
                    '<div class="loading">Loading data (this may take a moment for large files)...</div>';
                
                const response = await fetch('./all_data.csv');
                const text = await response.text();
                
                document.getElementById('charts-container').innerHTML = 
                    '<div class="loading">Processing data...</div>';
                
                const { years: yearsData } = await parseCSV(text);
                
                // Get years sorted
                const years = Object.keys(yearsData).map(Number).sort((a, b) => a - b);
                
                const container = document.getElementById('charts-container');
                container.innerHTML = '';
                
                // Render charts one by one to avoid blocking
                for (const year of years) {
                    const chart = createYearChart(year, yearsData[year]);
                    container.appendChild(chart);
                    // Yield control after each chart
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
            } catch (error) {
                document.getElementById('charts-container').innerHTML = 
                    `<div class="loading" style="color: #e74c3c;">Error loading data: ${error.message}</div>`;
                console.error(error);
            }
        }

        // Load data on page load
        loadAndVisualize();
    </script>
</body>
</html>
