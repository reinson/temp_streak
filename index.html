<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Data Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            color: #333;
            margin: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header {
            margin-bottom: 30px;
            text-align: left;
        }

        .header h1 {
            font-size: 32px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 16px;
        }

        .header a {
            color: #3498db;
            text-decoration: none;
            margin-left: 15px;
        }

        .header a:hover {
            text-decoration: underline;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #7f8c8d;
            font-size: 18px;
        }

        .chart-container {
            margin-bottom: 5px;
            background: white;
            padding: 0;
            border-radius: 0;
            border: none;
            transition: all 0.3s ease-in-out;
            position: relative;
        }

        .chart-container.expanded {
            margin-top: 20px;
            margin-bottom: 25px;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .chart-container:last-child {
            margin-bottom: 0;
        }

        .chart-svg {
            width: 100%;
            height: 120px;
            display: block;
            transition: height 0.3s ease-in-out;
            overflow: visible;
        }

        .chart-container.expanded .chart-svg {
            height: 400px;
        }

        .hover-line {
            stroke: #2c3e50;
            stroke-width: 1;
            stroke-dasharray: 4,4;
            pointer-events: none;
            display: none;
        }

        .tooltip-bg {
            fill: rgba(44, 62, 80, 0.9);
            rx: 4;
            display: none;
            pointer-events: none;
        }

        .tooltip-text {
            fill: white;
            font-size: 12px;
            font-weight: 600;
            display: none;
            pointer-events: none;
        }

        .y-axis-label {
            font-size: 10px;
            fill: #95a5a6;
            text-anchor: end;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .chart-container.expanded .y-axis-label {
            opacity: 1;
        }

        .chart-label {
            font-size: 16px;
            fill: #2c3e50;
            font-weight: 700;
        }

        .chart-stats-text {
            font-size: 13px;
            fill: #7f8c8d;
        }

        .month-label {
            font-size: 10px;
            fill: #95a5a6;
            text-anchor: start;
        }

        .line {
            fill: none;
            stroke-width: 2.5;
            vector-effect: non-scaling-stroke;
        }

        .line-below-zero {
            stroke: #3498db;
        }

        .line-above-zero {
            stroke: #e74c3c;
        }

        .axis {
            stroke: #bdc3c7;
            stroke-width: 1;
        }

        .axis-text {
            font-size: 12px;
            fill: #95a5a6;
        }

        .streak-rect {
            fill: #e3f2fd;
            opacity: 0.6;
        }

        .streak-label {
            font-size: 10px;
            fill: #1976d2;
            font-weight: 600;
            text-anchor: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Temperatuuri andmete visualiseerimine</h1>
            <p id="nav-links"></p>
        </div>
        <div id="charts-container">
            <div class="loading">Andmete laadimine...</div>
        </div>
    </div>

    <script>
        const isToravere = window.location.pathname.includes('toravere');
        const dataFile = isToravere ? 'data/toravere_compacted.csv' : 'data/compacted_data.csv';
        const streaksDataFile = isToravere ? 'data/toravere_streaks.json' : 'data/streaks_data.json';
        const locationName = isToravere ? 'Tõravere' : 'Tartu';

        document.getElementById('nav-links').innerHTML = `
            <div style="margin-bottom: 10px;">
                <strong>Andmestik:</strong>
                <a href="${isToravere ? 'index.html' : 'index.html'}" style="${!isToravere ? 'font-weight: bold; text-decoration: underline;' : ''}">Tartu</a> | 
                <a href="${isToravere ? 'toravere.html' : 'toravere.html'}" style="${isToravere ? 'font-weight: bold; text-decoration: underline;' : ''}">Tõravere</a>
            </div>
            <div>
                <strong>Vaade:</strong>
                <a href="${isToravere ? 'toravere.html' : 'index.html'}" style="font-weight: bold; text-decoration: underline;">Graafik</a> | 
                <a href="${isToravere ? 'toravere-heatmap.html' : 'heatmap.html'}">Soojuskaart</a> | 
                <a href="${isToravere ? 'toravere-streaks.html' : 'streaks.html'}">Perioodid</a>
            </div>
        `;

        let streaksData = null;

        // Parse CSV data in chunks to avoid stack overflow
        async function parseCSV(text) {
            const years = {};
            let minTemp = Infinity;
            let maxTemp = -Infinity;
            
            // Process line by line without splitting entire file
            let currentPos = 0;
            let lineStart = 0;
            let lineNum = 0;
            
            while (currentPos < text.length) {
                // Find end of line
                let lineEnd = text.indexOf('\n', currentPos);
                if (lineEnd === -1) lineEnd = text.length;
                
                if (lineNum > 0) { // Skip header
                    const line = text.substring(lineStart, lineEnd).trim();
                    if (line) {
                        const parts = line.split(', ');
                        if (parts.length >= 2) {
                            const dateStr = parts[0];
                            const temp = parseFloat(parts[3] || parts[1]); // Use HourTemp (index 3) if available, else index 1
                            
                            if (!isNaN(temp)) {
                                const date = new Date(dateStr);
                                const year = date.getFullYear();
                                
                                if (!years[year]) {
                                    years[year] = [];
                                }
                                
                                years[year].push({
                                    date: date,
                                    temp: temp
                                });
                                
                                if (temp < minTemp) minTemp = temp;
                                if (temp > maxTemp) maxTemp = temp;
                            }
                        }
                    }
                }
                
                lineNum++;
                currentPos = lineEnd + 1;
                lineStart = currentPos;
                
                // Yield control periodically to avoid blocking
                if (lineNum % 100000 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Sort each year's data by date
            Object.keys(years).forEach(year => {
                years[year].sort((a, b) => a.date - b.date);
            });
            
            return { years, minTemp, maxTemp };
        }

        function getTopStreaks() {
            if (!streaksData || !streaksData["0"]) return [];
            return streaksData["0"].top10.map((s, i) => ({
                num: i + 1,
                from: new Date(s.start),
                to: new Date(s.end),
                duration: formatDuration(s.durationMs) + (s.isOngoing ? ' (ONGOING)' : '')
            }));
        }

        function formatDuration(ms) {
            const days = Math.floor(ms / (24 * 60 * 60 * 1000));
            const hours = Math.floor((ms % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
            const minutes = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
            
            let res = '';
            if (days > 0) res += days + 'p ';
            if (hours > 0) res += hours + 'h ';
            if (minutes > 0) res += minutes + 'm';
            return res.trim() || '0m';
        }

        // Downsample data to reduce points (for smoother rendering)
        function downsample(data, maxPoints = 3000) {
            if (data.length <= maxPoints) return data;
            
            const step = Math.ceil(data.length / maxPoints);
            const sampled = [];
            
            for (let i = 0; i < data.length; i += step) {
                sampled.push(data[i]);
            }
            
            // Always include the last point
            if (sampled[sampled.length - 1] !== data[data.length - 1]) {
                sampled.push(data[data.length - 1]);
            }
            
            return sampled;
        }

        // Create a line chart for a year
        function createYearChart(year, data) {
            // Use fixed viewBox width for consistent scaling, SVG will scale to 100% width
            const width = 1600; // Fixed viewBox width
            const height = 120;
            const expandedHeight = 400;
            const padding = { top: 25, right: 10, bottom: 20, left: 35 }; // More left padding for Y axis
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            const expandedChartHeight = expandedHeight - padding.top - padding.bottom;

            // Downsample data for rendering (keep all for stats and hover)
            const displayData = downsample(data, 3000);
            
            // Calculate stats using all data (iterative to avoid stack overflow)
            let sum = 0;
            let minYearTemp = Infinity;
            let maxYearTemp = -Infinity;
            for (let i = 0; i < data.length; i++) {
                const temp = data[i].temp;
                sum += temp;
                if (temp < minYearTemp) minYearTemp = temp;
                if (temp > maxYearTemp) maxYearTemp = temp;
            }
            const avgTemp = sum / data.length;

            // Create container
            const container = document.createElement('div');
            container.className = 'chart-container';

            // Create SVG (responsive width)
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'chart-svg');
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', height);

            // Create group for chart content
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${padding.left}, ${padding.top})`);

            // Fixed y-axis range
            const fixedMinTemp = -30;
            const fixedMaxTemp = 35;
            
            // Fixed x-domain: Jan 1 to Dec 31 of the year
            const yearStart = new Date(year, 0, 1); // January 1
            const yearEnd = new Date(year, 11, 31, 23, 59, 59); // December 31
            const yearDuration = yearEnd - yearStart;
            
            // Scale functions - x based on date, y based on temperature
            const xScale = (date) => {
                const dayOfYear = (date - yearStart) / yearDuration;
                return Math.max(0, Math.min(chartWidth, dayOfYear * chartWidth));
            };
            const getYScale = (h) => (temp) => h - ((temp - fixedMinTemp) / (fixedMaxTemp - fixedMinTemp)) * h;
            let yScale = getYScale(chartHeight);

            // Draw streaks for closed state
            getTopStreaks().forEach(streak => {
                const streakYearStart = new Date(year, 0, 1);
                const streakYearEnd = new Date(year, 11, 31, 23, 59, 59);
                if (streak.to >= streakYearStart && streak.from <= streakYearEnd) {
                    const streakStart = Math.max(streak.from, streakYearStart);
                    const streakEnd = Math.min(streak.to, streakYearEnd);
                    const x1 = xScale(streakStart);
                    const x2 = xScale(streakEnd);
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x1);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('width', Math.max(1, x2 - x1));
                    rect.setAttribute('height', chartHeight);
                    rect.setAttribute('class', 'streak-rect');
                    g.appendChild(rect);
                    
                    if (streakEnd - streakStart >= (streak.to - streak.from) / 2) {
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', x1 + (x2 - x1) / 2);
                        label.setAttribute('y', 8);
                        label.setAttribute('class', 'streak-label');
                        label.setAttribute('dominant-baseline', 'hanging');
                        label.textContent = `#${streak.num}: ${streak.duration}`;
                        g.appendChild(label);
                    }
                }
            });

            // Create path segments
            function createPathSegments(data, h) {
                const segments = [];
                let currentSegment = null;
                const ys = getYScale(h);
                
                for (let i = 0; i < data.length; i++) {
                    const point = data[i];
                    const isAboveZero = point.temp > 0;
                    const x = xScale(point.date);
                    const y = ys(point.temp);
                    
                    if (currentSegment === null) {
                        currentSegment = { isAboveZero, pathData: `M ${x} ${y}` };
                    } else if (currentSegment.isAboveZero !== isAboveZero) {
                        const prevPoint = data[i - 1];
                        const prevX = xScale(prevPoint.date);
                        const prevY = ys(prevPoint.temp);
                        const t = -prevPoint.temp / (point.temp - prevPoint.temp);
                        const zeroX = prevX + (x - prevX) * t;
                        const zeroY = ys(0);
                        currentSegment.pathData += ` L ${zeroX} ${zeroY}`;
                        segments.push(currentSegment);
                        currentSegment = { isAboveZero, pathData: `M ${zeroX} ${zeroY} L ${x} ${y}` };
                    } else {
                        currentSegment.pathData += ` L ${x} ${y}`;
                    }
                }
                if (currentSegment !== null) segments.push(currentSegment);
                return segments;
            }
            
            // Create month ticks
            const monthNames = ['Jaan', 'Veebr', 'Märts', 'Apr', 'Mai', 'Juuni', 'Juuli', 'Aug', 'Sept', 'Okt', 'Nov', 'Dets'];
            function drawMonthTicks(h) {
                const monthTicksGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                monthTicksGroup.setAttribute('class', 'month-ticks-group');
                for (let month = 0; month < 12; month++) {
                    const monthDate = new Date(year, month, 1);
                    const x = xScale(monthDate);
                    
                    const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tick.setAttribute('x1', x);
                    tick.setAttribute('y1', h);
                    tick.setAttribute('x2', x);
                    tick.setAttribute('y2', h + 4);
                    tick.setAttribute('class', 'axis');
                    monthTicksGroup.appendChild(tick);
                    
                    const monthLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    monthLabel.setAttribute('x', x + 4);
                    monthLabel.setAttribute('y', h + 4);
                    monthLabel.setAttribute('class', 'month-label');
                    monthLabel.setAttribute('dominant-baseline', 'middle');
                    monthLabel.textContent = monthNames[month];
                    monthTicksGroup.appendChild(monthLabel);
                }
                return monthTicksGroup;
            }

            // Draw Y-axis ticks
            function drawYAxis(h) {
                const yAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                yAxisGroup.setAttribute('class', 'y-axis-group');
                const ys = getYScale(h);
                for (let t = -30; t <= 35; t += 10) {
                    const y = ys(t);
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', -5);
                    label.setAttribute('y', y);
                    label.setAttribute('class', 'y-axis-label');
                    label.setAttribute('dominant-baseline', 'middle');
                    label.textContent = `${t}°`;
                    yAxisGroup.appendChild(label);
                }
                return yAxisGroup;
            }

            // Draw zero line
            function drawZeroLine(h) {
                const ys = getYScale(h);
                const zeroY = ys(0);
                const zeroLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                zeroLine.setAttribute('x1', 0);
                zeroLine.setAttribute('y1', zeroY);
                zeroLine.setAttribute('x2', chartWidth);
                zeroLine.setAttribute('y2', zeroY);
                zeroLine.setAttribute('class', 'axis zero-line');
                zeroLine.setAttribute('stroke-width', '1.5');
                zeroLine.setAttribute('stroke-dasharray', '4,4');
                zeroLine.setAttribute('opacity', '0.7');
                return zeroLine;
            }

            // Initial render
            const segments = createPathSegments(displayData, chartHeight);
            segments.forEach(segment => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', segment.pathData);
                path.setAttribute('class', `line ${segment.isAboveZero ? 'line-above-zero' : 'line-below-zero'}`);
                g.appendChild(path);
            });

            g.appendChild(drawZeroLine(chartHeight));
            g.appendChild(drawMonthTicks(chartHeight));
            g.appendChild(drawYAxis(chartHeight));

            // Hover elements
            const hoverLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hoverLine.setAttribute('class', 'hover-line');
            hoverLine.setAttribute('y1', 0);
            hoverLine.setAttribute('y2', chartHeight);
            g.appendChild(hoverLine);

            const tooltipBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            tooltipBg.setAttribute('class', 'tooltip-bg');
            tooltipBg.setAttribute('height', 24);
            g.appendChild(tooltipBg);

            const tooltipText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tooltipText.setAttribute('class', 'tooltip-text');
            tooltipText.setAttribute('dominant-baseline', 'middle');
            g.appendChild(tooltipText);

            svg.appendChild(g);

            // Add static labels
            const yearLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yearLabel.setAttribute('x', padding.left);
            yearLabel.setAttribute('y', 15);
            yearLabel.setAttribute('class', 'chart-label');
            yearLabel.setAttribute('dominant-baseline', 'middle');
            yearLabel.textContent = year;
            svg.appendChild(yearLabel);
            
            const statsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            statsText.setAttribute('x', width - padding.right);
            statsText.setAttribute('y', 15);
            statsText.setAttribute('class', 'chart-stats-text');
            statsText.setAttribute('text-anchor', 'end');
            statsText.setAttribute('dominant-baseline', 'middle');
            statsText.textContent = `Keskm: ${avgTemp.toFixed(1)}°C | Min: ${minYearTemp.toFixed(1)}°C | Max: ${maxYearTemp.toFixed(1)}°C`;
            svg.appendChild(statsText);

            // Hover interaction
            container.addEventListener('mouseenter', () => {
                container.classList.add('expanded');
                svg.setAttribute('viewBox', `0 0 ${width} ${expandedHeight}`);
                
                // Update elements for expanded state
                const newYS = getYScale(expandedChartHeight);
                g.innerHTML = ''; // Clear and redraw
                
                // Re-draw streaks (drawn first to be in background)
                getTopStreaks().forEach(streak => {
                    const yearStart = new Date(year, 0, 1);
                    const yearEnd = new Date(year, 11, 31, 23, 59, 59);
                    if (streak.to >= yearStart && streak.from <= yearEnd) {
                        const streakStart = Math.max(streak.from, yearStart);
                        const streakEnd = Math.min(streak.to, yearEnd);
                        const x1 = xScale(streakStart);
                        const x2 = xScale(streakEnd);
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x1);
                        rect.setAttribute('y', 0);
                        rect.setAttribute('width', Math.max(1, x2 - x1));
                        rect.setAttribute('height', expandedChartHeight);
                        rect.setAttribute('class', 'streak-rect');
                        g.appendChild(rect);
                        
                        if (streakEnd - streakStart >= (streak.to - streak.from) / 2) {
                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.setAttribute('x', x1 + (x2 - x1) / 2);
                            label.setAttribute('y', 8);
                            label.setAttribute('class', 'streak-label');
                            label.setAttribute('dominant-baseline', 'hanging');
                            label.textContent = `#${streak.num}: ${streak.duration}`;
                            g.appendChild(label);
                        }
                    }
                });

                const expandedSegments = createPathSegments(displayData, expandedChartHeight);
                expandedSegments.forEach(segment => {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', segment.pathData);
                    path.setAttribute('class', `line ${segment.isAboveZero ? 'line-above-zero' : 'line-below-zero'}`);
                    g.appendChild(path);
                });

                g.appendChild(drawZeroLine(expandedChartHeight));
                g.appendChild(drawMonthTicks(expandedChartHeight));
                g.appendChild(drawYAxis(expandedChartHeight));
                
                // Re-add hover elements
                hoverLine.setAttribute('y2', expandedChartHeight);
                g.appendChild(hoverLine);
                g.appendChild(tooltipBg);
                g.appendChild(tooltipText);
            });

            container.addEventListener('mouseleave', () => {
                container.classList.remove('expanded');
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                hoverLine.style.display = 'none';
                tooltipBg.style.display = 'none';
                tooltipText.style.display = 'none';

                // Reset elements for small state
                g.innerHTML = '';
                
                // Re-draw streaks for closed state
                getTopStreaks().forEach(streak => {
                    const yearStart = new Date(year, 0, 1);
                    const yearEnd = new Date(year, 11, 31, 23, 59, 59);
                    if (streak.to >= yearStart && streak.from <= yearEnd) {
                        const streakStart = Math.max(streak.from, yearStart);
                        const streakEnd = Math.min(streak.to, yearEnd);
                        const x1 = xScale(streakStart);
                        const x2 = xScale(streakEnd);
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x1);
                        rect.setAttribute('y', 0);
                        rect.setAttribute('width', Math.max(1, x2 - x1));
                        rect.setAttribute('height', chartHeight);
                        rect.setAttribute('class', 'streak-rect');
                        g.appendChild(rect);
                        
                        if (streakEnd - streakStart >= (streak.to - streak.from) / 2) {
                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.setAttribute('x', x1 + (x2 - x1) / 2);
                            label.setAttribute('y', 8);
                            label.setAttribute('class', 'streak-label');
                            label.setAttribute('dominant-baseline', 'hanging');
                            label.textContent = `#${streak.num}: ${streak.duration}`;
                            g.appendChild(label);
                        }
                    }
                });

                const smallSegments = createPathSegments(displayData, chartHeight);
                smallSegments.forEach(segment => {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', segment.pathData);
                    path.setAttribute('class', `line ${segment.isAboveZero ? 'line-above-zero' : 'line-below-zero'}`);
                    g.appendChild(path);
                });
                g.appendChild(drawZeroLine(chartHeight));
                g.appendChild(drawMonthTicks(chartHeight));
                g.appendChild(drawYAxis(chartHeight));
                hoverLine.setAttribute('y2', chartHeight);
                g.appendChild(hoverLine);
                g.appendChild(tooltipBg);
                g.appendChild(tooltipText);
            });

            container.addEventListener('mousemove', (e) => {
                const rect = svg.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (width / rect.width);
                const chartX = x - padding.left;

                if (chartX >= 0 && chartX <= chartWidth) {
                    hoverLine.style.display = 'block';
                    hoverLine.setAttribute('x1', chartX);
                    hoverLine.setAttribute('x2', chartX);

                    // Find closest data point
                    const targetDate = new Date(yearStart.getTime() + (chartX / chartWidth) * yearDuration);
                    
                    // Binary search for closest point
                    let left = 0, right = data.length - 1;
                    while (left < right) {
                        let mid = Math.floor((left + right) / 2);
                        if (data[mid].date < targetDate) left = mid + 1;
                        else right = mid;
                    }
                    const point = data[left];

                    if (point) {
                        const timeStr = point.date.toLocaleTimeString('et-EE', { hour: '2-digit', minute: '2-digit' });
                        const dateStr = point.date.toLocaleDateString('et-EE', { month: 'short', day: 'numeric' });
                        const text = `${dateStr} ${timeStr}: ${point.temp.toFixed(1)}°C`;
                        tooltipText.textContent = text;
                        tooltipText.style.display = 'block';
                        
                        const textWidth = tooltipText.getComputedTextLength();
                        tooltipBg.setAttribute('width', textWidth + 10);
                        tooltipBg.style.display = 'block';

                        let tooltipX = chartX + 10;
                        if (tooltipX + textWidth + 10 > chartWidth) tooltipX = chartX - textWidth - 20;
                        
                        const fixedY = 5; // Fixed height near the top of the chart area
                        
                        tooltipBg.setAttribute('x', tooltipX);
                        tooltipBg.setAttribute('y', fixedY);
                        tooltipText.setAttribute('x', tooltipX + 5);
                        tooltipText.setAttribute('y', fixedY + 12); // Vertically centered in the 24px background
                    }
                } else {
                    hoverLine.style.display = 'none';
                    tooltipBg.style.display = 'none';
                    tooltipText.style.display = 'none';
                }
            });

            container.appendChild(svg);
            return container;
        }

        // Main function
        async function loadAndVisualize() {
            try {
                document.getElementById('charts-container').innerHTML = 
                    '<div class="loading">Andmete laadimine (suurte failide puhul võib see aega võtta)...</div>';
                
                const [csvResponse, streaksResponse] = await Promise.all([
                    fetch('./' + dataFile + '?t=' + new Date().getTime()),
                    fetch('./' + streaksDataFile + '?t=' + new Date().getTime())
                ]);
                
                const text = await csvResponse.text();
                streaksData = await streaksResponse.json();
                
                document.getElementById('charts-container').innerHTML = 
                    '<div class="loading">Andmete töötlemine...</div>';
                
                const { years: yearsData } = await parseCSV(text);
                
                // Get years sorted
                const years = Object.keys(yearsData).map(Number).sort((a, b) => a - b);
                
                const container = document.getElementById('charts-container');
                container.innerHTML = '';
                
                // Render charts one by one to avoid blocking
                for (const year of years) {
                    const chart = createYearChart(year, yearsData[year]);
                    container.appendChild(chart);
                    // Yield control after each chart
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
            } catch (error) {
                document.getElementById('charts-container').innerHTML = 
                    `<div class="loading" style="color: #e74c3c;">Viga andmete laadimisel: ${error.message}</div>`;
                console.error(error);
            }
        }

        // Load data on page load
        loadAndVisualize();
    </script>
</body>
</html>
