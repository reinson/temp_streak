<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Data Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            color: #333;
            margin: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header {
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 16px;
        }

        .header a {
            color: #3498db;
            text-decoration: none;
            margin-left: 15px;
        }

        .header a:hover {
            text-decoration: underline;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #7f8c8d;
            font-size: 18px;
        }

        .chart-container {
            margin-bottom: 5px;
            background: white;
            padding: 0;
            border-radius: 0;
            border: none;
        }

        .chart-container:last-child {
            margin-bottom: 0;
        }

        .chart-svg {
            width: 100%;
            height: 120px;
            display: block;
        }

        .chart-label {
            font-size: 16px;
            fill: #2c3e50;
            font-weight: 700;
        }

        .chart-stats-text {
            font-size: 13px;
            fill: #7f8c8d;
        }

        .month-label {
            font-size: 10px;
            fill: #95a5a6;
            text-anchor: start;
        }

        .line {
            fill: none;
            stroke-width: 2.5;
            vector-effect: non-scaling-stroke;
        }

        .line-below-zero {
            stroke: #3498db;
        }

        .line-above-zero {
            stroke: #e74c3c;
        }

        .axis {
            stroke: #bdc3c7;
            stroke-width: 1;
        }

        .axis-text {
            font-size: 12px;
            fill: #95a5a6;
        }

        .streak-rect {
            fill: #e3f2fd;
            opacity: 0.6;
        }

        .streak-label {
            font-size: 10px;
            fill: #1976d2;
            font-weight: 600;
            text-anchor: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Temperature Data Visualization</h1>
            <p>Yearly temperature trends over time | <a href="/compact">Compact View</a></p>
        </div>
        <div id="charts-container">
            <div class="loading">Loading data...</div>
        </div>
    </div>

    <script>
        // Parse CSV data in chunks to avoid stack overflow
        async function parseCSV(text) {
            const years = {};
            let minTemp = Infinity;
            let maxTemp = -Infinity;
            
            // Process line by line without splitting entire file
            let currentPos = 0;
            let lineStart = 0;
            let lineNum = 0;
            
            while (currentPos < text.length) {
                // Find end of line
                let lineEnd = text.indexOf('\n', currentPos);
                if (lineEnd === -1) lineEnd = text.length;
                
                if (lineNum > 0) { // Skip header
                    const line = text.substring(lineStart, lineEnd).trim();
                    if (line) {
                        const commaIdx = line.indexOf(', ');
                        if (commaIdx > 0) {
                            const dateStr = line.substring(0, commaIdx);
                            const temp = parseFloat(line.substring(commaIdx + 2));
                            
                            if (!isNaN(temp)) {
                                const date = new Date(dateStr);
                                const year = date.getFullYear();
                                
                                if (!years[year]) {
                                    years[year] = [];
                                }
                                
                                years[year].push({
                                    date: date,
                                    temp: temp
                                });
                                
                                if (temp < minTemp) minTemp = temp;
                                if (temp > maxTemp) maxTemp = temp;
                            }
                        }
                    }
                }
                
                lineNum++;
                currentPos = lineEnd + 1;
                lineStart = currentPos;
                
                // Yield control periodically to avoid blocking
                if (lineNum % 100000 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Sort each year's data by date
            Object.keys(years).forEach(year => {
                years[year].sort((a, b) => a.date - b.date);
            });
            
            return { years, minTemp, maxTemp };
        }

        // Define the top 10 longest streaks below 0째C
        const topStreaks = [
            { num: 1, from: new Date('2009-12-29T01:10:00'), to: new Date('2010-02-23T14:20:00'), duration: '56d 13h 10m' },
            { num: 2, from: new Date('2006-01-30T16:15:00'), to: new Date('2006-03-14T11:25:00'), duration: '42d 19h 10m' },
            { num: 3, from: new Date('2012-01-13T11:15:00'), to: new Date('2012-02-20T04:05:00'), duration: '37d 16h 50m' },
            { num: 4, from: new Date('2025-12-29T07:35:00'), to: new Date('2026-02-01T00:00:00'), duration: '33d 13h 39m (ONGOING)' },
            { num: 5, from: new Date('2005-02-12T13:25:00'), to: new Date('2005-03-17T14:25:00'), duration: '33d 1h' },
            { num: 6, from: new Date('2010-12-07T03:35:00'), to: new Date('2011-01-07T20:05:00'), duration: '31d 16h 30m' },
            { num: 7, from: new Date('2022-11-17T17:30:00'), to: new Date('2022-12-18T22:35:00'), duration: '31d 5h 5m' },
            { num: 8, from: new Date('2015-12-26T15:20:00'), to: new Date('2016-01-26T09:30:00'), duration: '30d 18h 10m' },
            { num: 9, from: new Date('2014-01-12T00:10:00'), to: new Date('2014-02-07T09:35:00'), duration: '26d 9h 25m' },
            { num: 10, from: new Date('2013-01-05T05:05:00'), to: new Date('2013-01-30T13:45:00'), duration: '25d 8h 40m' }
        ];

        // Downsample data to reduce points (for smoother rendering)
        function downsample(data, maxPoints = 3000) {
            if (data.length <= maxPoints) return data;
            
            const step = Math.ceil(data.length / maxPoints);
            const sampled = [];
            
            for (let i = 0; i < data.length; i += step) {
                sampled.push(data[i]);
            }
            
            // Always include the last point
            if (sampled[sampled.length - 1] !== data[data.length - 1]) {
                sampled.push(data[data.length - 1]);
            }
            
            return sampled;
        }

        // Create a line chart for a year
        function createYearChart(year, data) {
            // Use fixed viewBox width for consistent scaling, SVG will scale to 100% width
            const width = 1600; // Fixed viewBox width
            const height = 120;
            const padding = { top: 25, right: 10, bottom: 20, left: 10 }; // Top padding for labels, minimal side padding
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Downsample data for rendering (keep all for stats)
            const displayData = downsample(data, 3000);
            
            // Calculate stats using all data (iterative to avoid stack overflow)
            let sum = 0;
            let minYearTemp = Infinity;
            let maxYearTemp = -Infinity;
            for (let i = 0; i < data.length; i++) {
                const temp = data[i].temp;
                sum += temp;
                if (temp < minYearTemp) minYearTemp = temp;
                if (temp > maxYearTemp) maxYearTemp = temp;
            }
            const avgTemp = sum / data.length;

            // Create SVG (responsive width)
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'chart-svg');
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', height);

            // Create group for chart content
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${padding.left}, ${padding.top})`);

            // Fixed y-axis range
            const fixedMinTemp = -30;
            const fixedMaxTemp = 35;
            
            // Fixed x-domain: Jan 1 to Dec 31 of the year
            const yearStart = new Date(year, 0, 1); // January 1
            const yearEnd = new Date(year, 11, 31, 23, 59, 59); // December 31
            const yearDuration = yearEnd - yearStart;
            
            // Scale functions - x based on date, y based on temperature
            const xScale = (date) => {
                const dayOfYear = (date - yearStart) / yearDuration;
                return Math.max(0, Math.min(chartWidth, dayOfYear * chartWidth));
            };
            const yScale = (temp) => chartHeight - ((temp - fixedMinTemp) / (fixedMaxTemp - fixedMinTemp)) * chartHeight;

            // Split data into segments above and below zero
            function createPathSegments(data) {
                const segments = [];
                let currentSegment = null;
                
                for (let i = 0; i < data.length; i++) {
                    const point = data[i];
                    const isAboveZero = point.temp > 0;
                    const x = xScale(point.date);
                    const y = yScale(point.temp);
                    
                    if (currentSegment === null) {
                        // Start first segment
                        currentSegment = {
                            isAboveZero: isAboveZero,
                            pathData: `M ${x} ${y}`
                        };
                    } else if (currentSegment.isAboveZero !== isAboveZero) {
                        // Crossing zero - calculate intersection point
                        const prevPoint = data[i - 1];
                        const prevX = xScale(prevPoint.date);
                        const prevY = yScale(prevPoint.temp);
                        
                        // Linear interpolation to find zero crossing
                        const t = -prevPoint.temp / (point.temp - prevPoint.temp);
                        const zeroX = prevX + (x - prevX) * t;
                        const zeroY = yScale(0);
                        
                        // Close current segment at zero
                        currentSegment.pathData += ` L ${zeroX} ${zeroY}`;
                        segments.push(currentSegment);
                        
                        // Start new segment from zero
                        currentSegment = {
                            isAboveZero: isAboveZero,
                            pathData: `M ${zeroX} ${zeroY} L ${x} ${y}`
                        };
                    } else {
                        // Continue current segment
                        currentSegment.pathData += ` L ${x} ${y}`;
                    }
                }
                
                if (currentSegment !== null) {
                    segments.push(currentSegment);
                }
                
                return segments;
            }
            
            // Create month tick marks with labels
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            function createMonthTicks() {
                const ticks = [];
                for (let month = 0; month < 12; month++) {
                    const monthDate = new Date(year, month, 1);
                    const x = xScale(monthDate);
                    ticks.push({ x, month });
                }
                return ticks;
            }
            
            // Draw streak rectangles (before the line so they appear behind)
            topStreaks.forEach(streak => {
                // Check if streak overlaps with this year
                const yearStart = new Date(year, 0, 1);
                const yearEnd = new Date(year, 11, 31, 23, 59, 59);
                
                // Check if streak overlaps with this year
                if (streak.to >= yearStart && streak.from <= yearEnd) {
                    // Calculate the start and end x positions
                    const streakStart = Math.max(streak.from, yearStart);
                    const streakEnd = Math.min(streak.to, yearEnd);
                    
                    // Calculate duration in this year
                    const durationInThisYear = streakEnd - streakStart;
                    
                    // Calculate total streak duration
                    const totalDuration = streak.to - streak.from;
                    
                    // Calculate duration in the other year (if streak spans years)
                    const durationInOtherYear = totalDuration - durationInThisYear;
                    
                    // Only show label if this year's portion is longer (or equal)
                    const showLabel = durationInThisYear >= durationInOtherYear;
                    
                    const x1 = xScale(streakStart);
                    const x2 = xScale(streakEnd);
                    const rectWidth = Math.max(1, x2 - x1);
                    
                    // Draw rectangle covering full height
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x1);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('width', rectWidth);
                    rect.setAttribute('height', chartHeight);
                    rect.setAttribute('class', 'streak-rect');
                    g.appendChild(rect);
                    
                    // Add label with streak number and duration (only if this year's portion is longer)
                    if (showLabel) {
                        const labelX = x1 + rectWidth / 2;
                        const labelY = 8; // Position near top of rectangle
                        
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', labelX);
                        label.setAttribute('y', labelY);
                        label.setAttribute('class', 'streak-label');
                        label.setAttribute('dominant-baseline', 'hanging'); // Align to top
                        label.textContent = `#${streak.num}: ${streak.duration}`;
                        g.appendChild(label);
                    }
                }
            });

            // Create path segments
            const segments = createPathSegments(displayData);
            
            // Render each segment with appropriate color
            segments.forEach(segment => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', segment.pathData);
                path.setAttribute('class', `line ${segment.isAboveZero ? 'line-above-zero' : 'line-below-zero'}`);
                g.appendChild(path);
            });

            // Add zero line (freezing point) - full width, more prominent
            const zeroY = yScale(0);
            if (zeroY >= 0 && zeroY <= chartHeight) {
                const zeroLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                zeroLine.setAttribute('x1', 0);
                zeroLine.setAttribute('y1', zeroY);
                zeroLine.setAttribute('x2', chartWidth);
                zeroLine.setAttribute('y2', zeroY);
                zeroLine.setAttribute('class', 'axis');
                zeroLine.setAttribute('stroke-width', '1.5');
                zeroLine.setAttribute('stroke-dasharray', '4,4');
                zeroLine.setAttribute('opacity', '0.7');
                g.appendChild(zeroLine);
            }
            
            // Add month tick marks and labels
            const monthTicks = createMonthTicks();
            monthTicks.forEach(({ x, month }) => {
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', chartHeight);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', chartHeight + 4);
                tick.setAttribute('class', 'axis');
                tick.setAttribute('stroke-width', '1');
                g.appendChild(tick);
                
                // Add month label next to the tick
                const monthLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                monthLabel.setAttribute('x', x + 4); // Small offset to the right of the tick
                monthLabel.setAttribute('y', chartHeight + 4); // Align with bottom of tick
                monthLabel.setAttribute('class', 'month-label');
                monthLabel.setAttribute('dominant-baseline', 'middle');
                monthLabel.textContent = monthNames[month];
                g.appendChild(monthLabel);
            });

            svg.appendChild(g);

            // Add year label above the chart (on the left)
            const yearLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yearLabel.setAttribute('x', padding.left);
            yearLabel.setAttribute('y', 15);
            yearLabel.setAttribute('class', 'chart-label');
            yearLabel.setAttribute('dominant-baseline', 'middle');
            yearLabel.textContent = year;
            svg.appendChild(yearLabel);
            
            // Add stats above the chart (on the right)
            const statsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            statsText.setAttribute('x', width - padding.right);
            statsText.setAttribute('y', 15);
            statsText.setAttribute('class', 'chart-stats-text');
            statsText.setAttribute('text-anchor', 'end');
            statsText.setAttribute('dominant-baseline', 'middle');
            statsText.textContent = `Avg: ${avgTemp.toFixed(1)}째C | Min: ${minYearTemp.toFixed(1)}째C | Max: ${maxYearTemp.toFixed(1)}째C`;
            svg.appendChild(statsText);

            // Create container
            const container = document.createElement('div');
            container.className = 'chart-container';
            container.appendChild(svg);
            
            return container;
        }

        // Main function
        async function loadAndVisualize() {
            try {
                document.getElementById('charts-container').innerHTML = 
                    '<div class="loading">Loading data (this may take a moment for large files)...</div>';
                
                const response = await fetch('./all_data.csv');
                const text = await response.text();
                
                document.getElementById('charts-container').innerHTML = 
                    '<div class="loading">Processing data...</div>';
                
                const { years: yearsData } = await parseCSV(text);
                
                // Get years sorted
                const years = Object.keys(yearsData).map(Number).sort((a, b) => a - b);
                
                const container = document.getElementById('charts-container');
                container.innerHTML = '';
                
                // Render charts one by one to avoid blocking
                for (const year of years) {
                    const chart = createYearChart(year, yearsData[year]);
                    container.appendChild(chart);
                    // Yield control after each chart
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
            } catch (error) {
                document.getElementById('charts-container').innerHTML = 
                    `<div class="loading" style="color: #e74c3c;">Error loading data: ${error.message}</div>`;
                console.error(error);
            }
        }

        // Load data on page load
        loadAndVisualize();
    </script>
</body>
</html>
